# 네트워크 질문 덱

### OSI 7계층

<details>
  <summary>OSI 7계층의 각 계층의 명칭과 역할은?</summary>

##### 초안  

1계층은 피지컬 계층으로 케이블과 같은 장비를 통한 물리적인 연결으로 데이터를 전기신호로 변환해 전송하고,
2계층은 데이터링크 계층으로 로컬네트워크에서 데이터를 안전하게 전송하는 역할을 하며 mac주소를 사용하고 스위치등의 장비가 있습니다.
3계층은 네트워크 계층으로 라우터와 ip 주소를 사용합니다. 3계층부터 원격지 네트워크와 통신이 가능하며 데이터를 안전하고 빠르게 전송하는 역할을 담당합니다.
4계층은 트랜스포트 계층으로 tcp나 udp 프로토콜을 사용하고 신뢰할 수 있는 데이터를 주고 받을 수 있도록 해준다
5계층은 세션 계층으로 포트를 통해 통신 장치 간에 연결을 관리합니다
6계층은 프레젠테이션 계층으로 압축, 인코딩,디코딩, 암호화,복호화등의 작업을 합니다.
7계층은 어플리케이션 계층으로 사용자가 직접 상호작용하는 계층입니다. http, smtp 등의 프로토콜을 사용합니다

##### chatgpt

물리 계층 (Physical Layer):
역할: 장치 간의 물리적 연결을 다루며, 케이블, 커넥터, 전송 속도 등과 같은 하드웨어 측면을 정의합니다.
기능: 비트 인코딩, 신호 전송, 물리적 토폴로지 및 전송 미디어 특성.

데이터 링크 계층 (Data Link Layer):
역할: 물리 계층 상에서 안정적인 포인트 투 포인트 및 포인트 투 멀티포인트 통신을 보장합니다.
기능: 프레임화, 주소 지정, 오류 감지 및 흐름 제어.
두 개의 하위 계층으로 나뉨: 논리적 링크 제어 (Logical Link Control, LLC) 및 미디어 액세스 제어 (Media Access Control, MAC).

네트워크 계층 (Network Layer):
역할: 다른 네트워크에 위치한 장치 간의 데이터 패킷을 주소 지정, 라우팅 및 전달합니다.
기능: 논리적 주소 지정, 라우팅, 패킷 전달 및 단편화 및 재조립.

전송 계층 (Transport Layer):
역할: 서로 다른 호스트 상의 장치 간의 최종 통신, 신뢰성 및 오류 검출 및 수정을 보장합니다.
기능: 세분화 및 재조립, 흐름 제어, 오류 검출 및 수정, 최종 통신.

세션 계층 (Session Layer):
역할: 응용 프로그램 간에 세션 또는 연결을 관리하여 통신을 설정, 유지 및 종료합니다.
기능: 대화 제어, 동기화 및 세션 관리.

표현 계층 (Presentation Layer):
역할: 데이터 변환, 암호화 및 압축을 다루어 정보가 송신자와 수신자가 이해할 수 있는 형식으로 교환되도록 합니다.
기능: 변환, 암호화, 압축 및 형식 지정.

응용 계층 (Application Layer):
역할: 네트워크 서비스를 최종 사용자 및 응용 프로세스에 직접 제공하며 네트워크와 사용자 소프트웨어 간의 인터페이스 역할을 합니다.
기능: 네트워크 가상 터미널, 파일 전송, 네트워크 관리 및 응용 프로토콜 (예: HTTP, SMTP).
이러한 계층들은 서로 다른 시스템 및 장치 간의 상호 운용성을 표준화하는 포괄적인 프레임워크를 형성합니다.
</details>

<details>
  <summary>TCP/IP 모델과 OSI 모델의 차이는?</summary>
  <br>

  ##### 초안 
  
  tcp/ip모델은 사용되는 프로토콜을 기반으로 실제 네트워크에 사용되며 osi 모델은 보다 이론적인 모델로 네트워크 동작과 다를 수 있지만 여전히 네트워크 문제를 해결하는데 유용합니다.
  <br>

  ##### chatgpt

  레이어 수: OSI에는 7개의 레이어가 있고, TCP/IP에는 4개의 레이어가 있습니다.
  특정 프로토콜: TCP/IP 모델은 실제로 사용되는 프로토콜(TCP, IP 등)을 기반으로 개발된 반면, OSI 모델은 이론적 프레임워크로 만들어졌습니다.
  유연성: TCP/IP 모델은 보다 유연한 것으로 간주되어 특히 인터넷 환경에서 실제 구현을 위해 널리 채택되었습니다.
  실제로 두 모델 모두 참조 지점으로 자주 사용되지만 실제 네트워킹 시나리오에서는 TCP/IP 모델이 더 널리 사용됩니다.
</details>

### TCP, UDP

<details>
  <summary>TCP와 UDP의 차이</summary>
  <h5> 초안 </h5> 
    tcp는 높은 신뢰성을 보장하고 흐름제어, 혼잡제어 같은 기능을 제공하며, 
    udp는 신뢰성보다는 속도을 중요시하고 1대다 전송이 필요한 경우 사용합니다.
  <h5> chatgpt </h5> 
    TCP는 연결 지향적이고 신뢰성 있는 전송을 보장하며, 데이터의 순서를 유지합니다. 
    UDP는 비연결성이며, 데이터 전송에 대한 보장이 없고 순서가 유지되지 않습니다.
</details>

<details>
  <summary>TCP의 흐름 제어와 혼잡 제어에 대해 간단히 설명해주세요</summary>
  <h5> 초안 </h5> 
    흐름제어는 수신자가 데이터를 처리할 수 있도록 데이터 전송량을 조절하는 것이고,
    혼잡제어는 네트워크 혼잡을 방지하기위해 송신측에서 강제로 데이터 전송량을 조절하는 것입니다.
    흐름제어가 송, 수신측 사이의 전송속도를 다루면, 혼잡제어는 라우터를 포함한 보다 넓은 관점에서 전송 문제를 다룹니다.
  <h5> chatgpt </h5> 
    TCP는 흐름 제어를 통해 수신자가 처리할 수 있는 속도로 데이터를 전송하고, 혼잡 제어를 통해 네트워크 혼잡을 방지합니다.
</details>
<details>
  <summary>TCP의 3way handshake에 대해 설명해주세요</summary>
  <h5> 초안 </h5> 
    3way handshake는 tcp에서 안전한 통신을 위한 사전연결작업입니다. 클라이언트가 서버측으로 syn를 보내 연결 요청을 하고, 해당 신호를 받은 서버는 클라이언트로 syn와 ack를 보내 요청을 수락하고, 마지막으로 클라이언트가 서버로 ack를 보내는 것으로 세션을 수립합니다.
  <h5> chatgpt </h5> 
    TCP 연결을 설정하기 위해 세 단계의 통신이 이루어지는데, SYN(연결 요청), SYN-ACK(수락 응답), ACK(연결 수립 확인) 순으로 진행됩니다.
</details>
<details>
  <summary>TCP의 연결설정과정과 종료과정의 단계가 다른 이유는?</summary>
  <h5> 초안 </h5> 
    클라이언트측에서 데이터 전송이 끝나도 서버측은 보낼 데이터가 남아 있을 수 있기 때문에 FIN 신호에 대한 ACK만 보내고, 남은 데이터를 클라이언트에 전송한 후에 자신도 FIN 신호를 보내 종료과정이 설정과정보다 1단계 더 많다.
  <h5> chatgpt </h5> 
</details>


### 로드밸런싱

<details>
  <summary>로드 밸런싱이란 무엇인가요</summary>
  <h5> 초안 </h5> 
    로드밸런싱은 2개이상의 서버를 사용해 트래픽을 분산시키고 가용성을 높히는 기술입니다.
    로드밸런싱을 사용하면 데이터를 빠르고 안정적으로 사용자에게 제공할 수 있습니다.
  <h5> chatgpt </h5> 
    로드 밸런싱은 네트워크나 서버에 가해지는 부하를 여러 대의 서버에 고르게 분산시켜 서버의 성능을 최적화하고 가용성을 높이는 기술입니다.
</details>

<details>
  <summary>로드 밸런싱 알고리즘에는 어떤것이 있나요?</summary>
  <h5> 초안 </h5> 
    알고리즘으로는 라운드로빈, 최소접속방식, 해시 등이 있습니다.
    라운드로빈은 연결된 서버에 순차적으로 부하를 분산하는 방식이고,
    최소접속방식은 활성화된 세션수가 가장 적은 서버에 부하를 분산하는 방식입니다.
    해시는 서버 상태를 고려하지 않고 해시 알고리즘을 통해 어떤 서버에 부하를 분산할지 결정하는 방식으로 항상 같은 장비에 연결해야하는 게임이나 세션기반 서비스에 적합합니다.
  <h5> chatgpt </h5> 
    로드 밸런싱 알고리즘에는 라운드 로빈, 가중 라운드 로빈, 최소 연결, 최소 부하, 최대 처리량 등이 있습니다. 각각의 알고리즘은 특정 상황에 적합하게 사용됩니다.
</details>

<details>
  <summary>로드 밸런서에는 어떤것이 있나요?</summary>
  <h5> 초안 </h5> 
    ip주소와 포트를 기반으로 트래픽을 분산하는 l4 로드밸런서와
    uri, http header, 쿠키 등을 통해 트래픽을 분산하는 l7 로드밸런서가 있습니다.
  <h5> chatgpt </h5> 
    로드 밸런서에는 레이어 4(L4) 밸런서와 레이어 7(L7) 밸런서가 있습니다. L4 밸런서는 전송 계층에서 동작하며 IP 주소와 포트를 기반으로 트래픽을 분배합니다. L7 밸런서는 애플리케이션 계층에서 동작하며 요청의 내용에 따라 분배합니다.
</details>

### REST

<details>
  <summary>REST란 무엇인가요?</summary>
  <h5> 초안 </h5> 
    Representational State Transfer의 약자로 네트워크 리소스를 표현하기 위한 일련의 원칙을 기반으로 하는 아키텍처 디자인입니다.
    반드시 지켜야할 표준은 아니지만 HTTP 프로토콜의 인프라를 사용해 추가적인 인프라 구축이 없고 가독성이 뛰어나 범용적으로 사용되고 있습니다.
  <h5> chatgpt </h5> 
    Representational State Transfer의 약자로, 분산 시스템에서 자원을 표현하고 상태를 전송하기 위한 아키텍처 스타일
</details>

<details>
  <summary>REST API의 구성요소에는 무엇이있나요?</summary>
  <h5> 초안 </h5> 
    REST는 자원, 행위, 표현 세가지 구성요소로 이루어져있습니다.
    자원은 서버에 존재하며 uri를 통해 구분하고,
    행위는 get, post와 같은 http 메서드를 사용합니다.
    마지막으로 리소스는 json, xml 등 다양한 형태로 표현됩니다.
</details>

<details>
  <summary>REST란 무엇인가요?</summary>
  <h5> 초안 </h5> 
    Representational State Transfer의 약자로 네트워크 리소스를 표현하기 위한 일련의 원칙을 기반으로 하는 아키텍처 디자인입니다.
    반드시 지켜야할 표준은 아니지만 HTTP 프로토콜의 인프라를 사용해 추가적인 인프라 구축이 없고 가독성이 뛰어나 범용적으로 사용되고 있습니다.
  <h5> chatgpt </h5> 
    Representational State Transfer의 약자로, 분산 시스템에서 자원을 표현하고 상태를 전송하기 위한 아키텍처 스타일
</details>

### HTTP 메서드

<details>
  <summary>HTTP 메서드란?</summary>
  <h5> 초안 </h5> 
    http 메서드는 요청의 목적을 서버에게 알리는 수단으로 get, post, put, patch, delete 등이 있고 안정성, 멱등성 같은 속성을 가지고 있습니다.
    안정성은 요청시 리소스가 변경되지 않는 성질을 의미하고 get 만이 이 조건을 만족합니다.
    멱등성은 동일한 요청을 여러번 보냈을 때 서버에 미치는 의도된 영향이 동일한 경우를 의미하며 get, put, delete가 멱등성을 가지고 있습니다.
  <h5> chatgpt </h5> 
    HTTP 메서드는 클라이언트가 서버에게 요청을 보낼 때 어떤 종류의 동작을 원하는지를 나타내는 표준화된 방법입니다. 주요 HTTP 메서드로는 GET, POST, PUT, DELETE 등이 있습니다.
</details>

<details>
  <summary>GET과 POST 메서드의 차이점은 무엇인가요?</summary>
  <h5> 초안 </h5> 
    get메서드는 리소스를 조회할 때 사용하고 post는 새로운 리소스를 생성할 때 사용합니다.
    또한 body의 유무나 메서드의 속성으로도 비교할 수 있는데 get은 안정성과 멱등성을 가지고 있고 요청 데이터에 대한 정보를 url에 담아보내기 때문에 body가 없습니다. 
    그에 반해 post는 body에 데이터를 넣어보내고 암호화를 통해 안전하게 데이터를 전송할 수 있습니다.
  <h5> chatgpt </h5> 
    GET 메서드는 정보를 요청하기 위해 사용되며, 요청된 데이터는 URI에 포함되어 전송됩니다. 주로 데이터를 가져오는 데 사용되며, 요청이 캐시될 수 있습니다.
    POST 메서드는 리소스를 생성하거나 업데이트하기 위해 사용되며, 요청된 데이터는 요청 본문에 포함됩니다. 주로 데이터를 전송하고, 요청이 캐시되지 않습니다.
</details>

<details>
  <summary>그럼 GET과 POST 중 어떤 메서드의 속도가 더 빠르나요?</summary>
  <h5> 초안 </h5> 
    일반적으로는 속도에 차이가 없지만 캐시가능성을 고려하면 get이 더 빠르다고 생각합니다. 
  <h5> chatgpt </h5> 
    일반적으로 HTTP 요청의 GET 메서드와 POST 메서드 사이에는 속도에 큰 차이가 없습니다. 둘 사이의 선택은 의도된 목적에 따라 이루어져야 합니다. 즉, 데이터 검색을 위한 GET과 데이터 제출을 위한 POST입니다. 캐싱, 요청 크기, 멱등성 등의 요소가 성능에 영향을 미칠 수 있지만 일반적인 웹 애플리케이션에는 그 영향이 크지 않을 수 있습니다. 궁극적으로 효율성은 특정 사용 사례와 디자인이 얼마나 잘 접착되는지에 따라 달라집니다.
</details>

<details>
  <summary>PUT과 PATCH 메서드의 차이는 무엇인가요?</summary>
  <h5> 초안 </h5> 
    put과 patch 메서드의 차이는 멱등성으로 나눌 수 있습니다.
    put은 해당하는 리소스가 없으면 새로추가하고 있으면 수정하는 동작을 합니다.
    그래서 put은 멱등성을 만족하는데 patch도 동일하게 구현할 경우에는 멱등성을 만족합니다.
    대신 patch의 경우 동작을 "특정값을 10증가시킨다" 처럼 적용하는 것이 가능해 멱등성을 만족하지 못합니다.
  <h5> chatgpt </h5> 
    PUT 메서드는 리소스를 생성하거나 업데이트하기 위해 사용되며, 요청된 데이터는 요청 본문에 포함됩니다. 일반적으로 식별된 리소스의 전체를 업데이트합니다.
    POST 메서드는 리소스를 생성하기 위해 사용되며, 요청된 데이터는 요청 본문에 포함됩니다. 일반적으로 서버가 새 리소스의 URI를 생성합니다.
</details>

<details>
  <summary>PATCH 메서드는 어느 경우에 사용하나요?</summary>
  <h5> 초안 </h5> 
    일반적으로 patch 메서드는 데이터를 부분적으로 수정하는 경우에 사용합니다. 
    요청 body는 수정할 부분만 포함하고 나머지는 기존값이 그대로 유지됩니다. 
    반면에 put 메서드는 데이터의 완전한 교체만 허용합니다.
  <h5> chatgpt </h5> 
    PATCH 메서드는 리소스의 부분적인 업데이트를 수행하기 위해 사용됩니다. 요청 본문에 업데이트할 부분만을 포함하고, 나머지 부분은 변경되지 않은 상태로 유지됩니다.
</details>

