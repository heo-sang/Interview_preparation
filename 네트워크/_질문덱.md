# 네트워크 질문 덱

### OSI 7계층

<details>
  <summary>OSI 7계층의 각 계층의 명칭과 역할은?</summary>

##### 초안  

1계층은 피지컬 계층으로 케이블과 같은 장비를 통한 물리적인 연결으로 데이터를 전기신호로 변환해 전송하고,
2계층은 데이터링크 계층으로 로컬네트워크에서 데이터를 안전하게 전송하는 역할을 하며 mac주소를 사용하고 스위치등의 장비가 있습니다.
3계층은 네트워크 계층으로 라우터와 ip 주소를 사용합니다. 3계층부터 원격지 네트워크와 통신이 가능하며 데이터를 안전하고 빠르게 전송하는 역할을 담당합니다.
4계층은 트랜스포트 계층으로 tcp나 udp 프로토콜을 사용하고 신뢰할 수 있는 데이터를 주고 받을 수 있도록 해준다
5계층은 세션 계층으로 포트를 통해 통신 장치 간에 연결을 관리합니다
6계층은 프레젠테이션 계층으로 압축, 인코딩,디코딩, 암호화,복호화등의 작업을 합니다.
7계층은 어플리케이션 계층으로 사용자가 직접 상호작용하는 계층입니다. http, smtp 등의 프로토콜을 사용합니다

##### chatgpt

물리 계층 (Physical Layer):
역할: 장치 간의 물리적 연결을 다루며, 케이블, 커넥터, 전송 속도 등과 같은 하드웨어 측면을 정의합니다.
기능: 비트 인코딩, 신호 전송, 물리적 토폴로지 및 전송 미디어 특성.

데이터 링크 계층 (Data Link Layer):
역할: 물리 계층 상에서 안정적인 포인트 투 포인트 및 포인트 투 멀티포인트 통신을 보장합니다.
기능: 프레임화, 주소 지정, 오류 감지 및 흐름 제어.
두 개의 하위 계층으로 나뉨: 논리적 링크 제어 (Logical Link Control, LLC) 및 미디어 액세스 제어 (Media Access Control, MAC).

네트워크 계층 (Network Layer):
역할: 다른 네트워크에 위치한 장치 간의 데이터 패킷을 주소 지정, 라우팅 및 전달합니다.
기능: 논리적 주소 지정, 라우팅, 패킷 전달 및 단편화 및 재조립.

전송 계층 (Transport Layer):
역할: 서로 다른 호스트 상의 장치 간의 최종 통신, 신뢰성 및 오류 검출 및 수정을 보장합니다.
기능: 세분화 및 재조립, 흐름 제어, 오류 검출 및 수정, 최종 통신.

세션 계층 (Session Layer):
역할: 응용 프로그램 간에 세션 또는 연결을 관리하여 통신을 설정, 유지 및 종료합니다.
기능: 대화 제어, 동기화 및 세션 관리.

표현 계층 (Presentation Layer):
역할: 데이터 변환, 암호화 및 압축을 다루어 정보가 송신자와 수신자가 이해할 수 있는 형식으로 교환되도록 합니다.
기능: 변환, 암호화, 압축 및 형식 지정.

응용 계층 (Application Layer):
역할: 네트워크 서비스를 최종 사용자 및 응용 프로세스에 직접 제공하며 네트워크와 사용자 소프트웨어 간의 인터페이스 역할을 합니다.
기능: 네트워크 가상 터미널, 파일 전송, 네트워크 관리 및 응용 프로토콜 (예: HTTP, SMTP).
이러한 계층들은 서로 다른 시스템 및 장치 간의 상호 운용성을 표준화하는 포괄적인 프레임워크를 형성합니다.
</details>

<details>
  <summary>TCP/IP 모델과 OSI 모델의 차이는?</summary>
  <br>

  ##### 초안 
  
  tcp/ip모델은 사용되는 프로토콜을 기반으로 실제 네트워크에 사용되며 osi 모델은 보다 이론적인 모델로 네트워크 동작과 다를 수 있지만 여전히 네트워크 문제를 해결하는데 유용합니다.
  <br>

  ##### chatgpt

  레이어 수: OSI에는 7개의 레이어가 있고, TCP/IP에는 4개의 레이어가 있습니다.
  특정 프로토콜: TCP/IP 모델은 실제로 사용되는 프로토콜(TCP, IP 등)을 기반으로 개발된 반면, OSI 모델은 이론적 프레임워크로 만들어졌습니다.
  유연성: TCP/IP 모델은 보다 유연한 것으로 간주되어 특히 인터넷 환경에서 실제 구현을 위해 널리 채택되었습니다.
  실제로 두 모델 모두 참조 지점으로 자주 사용되지만 실제 네트워킹 시나리오에서는 TCP/IP 모델이 더 널리 사용됩니다.
</details>

### TCP, UDP

<details>
  <summary>TCP와 UDP의 차이</summary>
  <h5> 초안 </h5> 
    tcp는 높은 신뢰성을 보장하고 흐름제어, 혼잡제어 같은 기능을 제공하며, 
    udp는 신뢰성보다는 속도을 중요시하고 1대다 전송이 필요한 경우 사용합니다.
  <h5> chatgpt </h5> 
    TCP는 연결 지향적이고 신뢰성 있는 전송을 보장하며, 데이터의 순서를 유지합니다. 
    UDP는 비연결성이며, 데이터 전송에 대한 보장이 없고 순서가 유지되지 않습니다.
</details>

<details>
  <summary>TCP의 흐름 제어와 혼잡 제어에 대해 간단히 설명해주세요</summary>
  <h5> 초안 </h5> 
    흐름제어는 수신자가 데이터를 처리할 수 있도록 데이터 전송량을 조절하는 것이고,
    혼잡제어는 네트워크 혼잡을 방지하기위해 송신측에서 강제로 데이터 전송량을 조절하는 것입니다.
    흐름제어가 송, 수신측 사이의 전송속도를 다루면, 혼잡제어는 라우터를 포함한 보다 넓은 관점에서 전송 문제를 다룹니다.
  <h5> chatgpt </h5> 
    TCP는 흐름 제어를 통해 수신자가 처리할 수 있는 속도로 데이터를 전송하고, 혼잡 제어를 통해 네트워크 혼잡을 방지합니다.
</details>
<details>
  <summary>TCP의 3way handshake에 대해 설명해주세요</summary>
  <h5> 초안 </h5> 
    3way handshake는 tcp에서 안전한 통신을 위한 사전연결작업입니다. 클라이언트가 서버측으로 syn를 보내 연결 요청을 하고, 해당 신호를 받은 서버는 클라이언트로 syn와 ack를 보내 요청을 수락하고, 마지막으로 클라이언트가 서버로 ack를 보내는 것으로 세션을 수립합니다.
  <h5> chatgpt </h5> 
    TCP 연결을 설정하기 위해 세 단계의 통신이 이루어지는데, SYN(연결 요청), SYN-ACK(수락 응답), ACK(연결 수립 확인) 순으로 진행됩니다.
</details>
<details>
  <summary>TCP의 연결설정과정과 종료과정의 단계가 다른 이유는?</summary>
  <h5> 초안 </h5> 
    클라이언트측에서 데이터 전송이 끝나도 서버측은 보낼 데이터가 남아 있을 수 있기 때문에 FIN 신호에 대한 ACK만 보내고, 남은 데이터를 클라이언트에 전송한 후에 자신도 FIN 신호를 보내 종료과정이 설정과정보다 1단계 더 많다.
  <h5> chatgpt </h5> 
</details>


### 로드밸런싱

<details>
  <summary>로드 밸런싱이란 무엇인가요</summary>
  <h5> 초안 </h5> 
    로드밸런싱은 2개이상의 서버를 사용해 트래픽을 분산시키고 가용성을 높히는 기술입니다.
    로드밸런싱을 사용하면 데이터를 빠르고 안정적으로 사용자에게 제공할 수 있습니다.
  <h5> chatgpt </h5> 
    로드 밸런싱은 네트워크나 서버에 가해지는 부하를 여러 대의 서버에 고르게 분산시켜 서버의 성능을 최적화하고 가용성을 높이는 기술입니다.
</details>

<details>
  <summary>로드 밸런싱 알고리즘에는 어떤것이 있나요?</summary>
  <h5> 초안 </h5> 
    알고리즘으로는 라운드로빈, 최소접속방식, 해시 등이 있습니다.
    라운드로빈은 연결된 서버에 순차적으로 부하를 분산하는 방식이고,
    최소접속방식은 활성화된 세션수가 가장 적은 서버에 부하를 분산하는 방식입니다.
    해시는 서버 상태를 고려하지 않고 해시 알고리즘을 통해 어떤 서버에 부하를 분산할지 결정하는 방식으로 항상 같은 장비에 연결해야하는 게임이나 세션기반 서비스에 적합합니다.
  <h5> chatgpt </h5> 
    로드 밸런싱 알고리즘에는 라운드 로빈, 가중 라운드 로빈, 최소 연결, 최소 부하, 최대 처리량 등이 있습니다. 각각의 알고리즘은 특정 상황에 적합하게 사용됩니다.
</details>

<details>
  <summary>로드 밸런서에는 어떤것이 있나요?</summary>
  <h5> 초안 </h5> 
    ip주소와 포트를 기반으로 트래픽을 분산하는 l4 로드밸런서와
    uri, http header, 쿠키 등을 통해 트래픽을 분산하는 l7 로드밸런서가 있습니다.
  <h5> chatgpt </h5> 
    로드 밸런서에는 레이어 4(L4) 밸런서와 레이어 7(L7) 밸런서가 있습니다. L4 밸런서는 전송 계층에서 동작하며 IP 주소와 포트를 기반으로 트래픽을 분배합니다. L7 밸런서는 애플리케이션 계층에서 동작하며 요청의 내용에 따라 분배합니다.
</details>

### REST

<details>
  <summary>REST란 무엇인가요?</summary>
  <h5> 초안 </h5> 
    Representational State Transfer의 약자로 네트워크 리소스를 표현하기 위한 일련의 원칙을 기반으로 하는 아키텍처 디자인입니다.
    반드시 지켜야할 표준은 아니지만 HTTP 프로토콜의 인프라를 사용해 추가적인 인프라 구축이 없고 가독성이 뛰어나 범용적으로 사용되고 있습니다.
  <h5> chatgpt </h5> 
    Representational State Transfer의 약자로, 분산 시스템에서 자원을 표현하고 상태를 전송하기 위한 아키텍처 스타일
</details>

<details>
  <summary>REST API의 구성요소에는 무엇이있나요?</summary>
  <h5> 초안 </h5> 
    REST는 자원, 행위, 표현 세가지 구성요소로 이루어져있습니다.
    자원은 서버에 존재하며 uri를 통해 구분하고,
    행위는 get, post와 같은 http 메서드를 사용합니다.
    마지막으로 리소스는 json, xml 등 다양한 형태로 표현됩니다.
</details>

<details>
  <summary>REST란 무엇인가요?</summary>
  <h5> 초안 </h5> 
    Representational State Transfer의 약자로 네트워크 리소스를 표현하기 위한 일련의 원칙을 기반으로 하는 아키텍처 디자인입니다.
    반드시 지켜야할 표준은 아니지만 HTTP 프로토콜의 인프라를 사용해 추가적인 인프라 구축이 없고 가독성이 뛰어나 범용적으로 사용되고 있습니다.
  <h5> chatgpt </h5> 
    Representational State Transfer의 약자로, 분산 시스템에서 자원을 표현하고 상태를 전송하기 위한 아키텍처 스타일
</details>

### HTTP 메서드

<details>
  <summary>HTTP 메서드란?</summary>
  <h5> 초안 </h5> 
    http 메서드는 요청의 목적을 서버에게 알리는 수단으로 get, post, put, patch, delete 등이 있고 안정성, 멱등성 같은 속성을 가지고 있습니다.
    안정성은 요청시 리소스가 변경되지 않는 성질을 의미하고 get 만이 이 조건을 만족합니다.
    멱등성은 동일한 요청을 여러번 보냈을 때 서버에 미치는 의도된 영향이 동일한 경우를 의미하며 get, put, delete가 멱등성을 가지고 있습니다.
  <h5> chatgpt </h5> 
    HTTP 메서드는 클라이언트가 서버에게 요청을 보낼 때 어떤 종류의 동작을 원하는지를 나타내는 표준화된 방법입니다. 주요 HTTP 메서드로는 GET, POST, PUT, DELETE 등이 있습니다.
</details>

<details>
  <summary>GET과 POST 메서드의 차이점은 무엇인가요?</summary>
  <h5> 초안 </h5> 
    get메서드는 리소스를 조회할 때 사용하고 post는 새로운 리소스를 생성할 때 사용합니다.
    또한 body의 유무나 메서드의 속성으로도 비교할 수 있는데 get은 안정성과 멱등성을 가지고 있고 요청 데이터에 대한 정보를 url에 담아보내기 때문에 body가 없습니다. 
    그에 반해 post는 body에 데이터를 넣어보내고 암호화를 통해 안전하게 데이터를 전송할 수 있습니다.
  <h5> chatgpt </h5> 
    GET 메서드는 정보를 요청하기 위해 사용되며, 요청된 데이터는 URI에 포함되어 전송됩니다. 주로 데이터를 가져오는 데 사용되며, 요청이 캐시될 수 있습니다.
    POST 메서드는 리소스를 생성하거나 업데이트하기 위해 사용되며, 요청된 데이터는 요청 본문에 포함됩니다. 주로 데이터를 전송하고, 요청이 캐시되지 않습니다.
</details>

<details>
  <summary>그럼 GET과 POST 중 어떤 메서드의 속도가 더 빠르나요?</summary>
  <h5> 초안 </h5> 
    일반적으로는 속도에 차이가 없지만 캐시가능성을 고려하면 get이 더 빠르다고 생각합니다. 
  <h5> chatgpt </h5> 
    일반적으로 HTTP 요청의 GET 메서드와 POST 메서드 사이에는 속도에 큰 차이가 없습니다. 둘 사이의 선택은 의도된 목적에 따라 이루어져야 합니다. 즉, 데이터 검색을 위한 GET과 데이터 제출을 위한 POST입니다. 캐싱, 요청 크기, 멱등성 등의 요소가 성능에 영향을 미칠 수 있지만 일반적인 웹 애플리케이션에는 그 영향이 크지 않을 수 있습니다. 궁극적으로 효율성은 특정 사용 사례와 디자인이 얼마나 잘 접착되는지에 따라 달라집니다.
</details>

<details>
  <summary>PUT과 PATCH 메서드의 차이는 무엇인가요?</summary>
  <h5> 초안 </h5> 
    put과 patch 메서드의 차이는 멱등성으로 나눌 수 있습니다.
    put은 해당하는 리소스가 없으면 새로추가하고 있으면 수정하는 동작을 합니다.
    그래서 put은 멱등성을 만족하는데 patch도 동일하게 구현할 경우에는 멱등성을 만족합니다.
    대신 patch의 경우 동작을 "특정값을 10증가시킨다" 처럼 적용하는 것이 가능해 멱등성을 만족하지 못합니다.
  <h5> chatgpt </h5> 
    PUT 메서드는 리소스를 생성하거나 업데이트하기 위해 사용되며, 요청된 데이터는 요청 본문에 포함됩니다. 일반적으로 식별된 리소스의 전체를 업데이트합니다.
    POST 메서드는 리소스를 생성하기 위해 사용되며, 요청된 데이터는 요청 본문에 포함됩니다. 일반적으로 서버가 새 리소스의 URI를 생성합니다.
</details>

<details>
  <summary>PATCH 메서드는 어느 경우에 사용하나요?</summary>
  <h5> 초안 </h5> 
    일반적으로 patch 메서드는 데이터를 부분적으로 수정하는 경우에 사용합니다. 
    요청 body는 수정할 부분만 포함하고 나머지는 기존값이 그대로 유지됩니다. 
    반면에 put 메서드는 데이터의 완전한 교체만 허용합니다.
  <h5> chatgpt </h5> 
    PATCH 메서드는 리소스의 부분적인 업데이트를 수행하기 위해 사용됩니다. 요청 본문에 업데이트할 부분만을 포함하고, 나머지 부분은 변경되지 않은 상태로 유지됩니다.
</details>

### 쿠키, 세션, JWT

<details>
  <summary>쿠키와 세션의 차이점은 무엇인가요?</summary>
  <h5> 초안 </h5> 
    쿠키와 세션의 가장 큰 차이점은 저장되는 장소입니다. 
    쿠키는 클라이언트에 저장되고 세션은 서버에 저장됩니다.
    서버에 저장되는 것으로 인해 세션을 사용할 경우 쿠키보다 보안성이 높지만 같은 서버에 연결해야만 사용할 수 있다는 단점이 있습니다.
    (서버 부하, 확장성 문제 추가)
  <h5> chatgpt </h5> 
    주요 차이는 데이터의 저장 위치입니다. 쿠키는 클라이언트의 브라우저에 저장되고, 세션은 서버에 저장됩니다. 또한, 쿠키는 클라이언트에서 직접 관리되지만, 세션은 서버에서 관리됩니다.
</details>

<details>
  <summary>쿠키와 세션의 동작방식은 어떻게 되나요?</summary>
  <h5> 초안 </h5> 
    클라이언트의 요청에 서버가 응답하면서 헤더에 set-cookie라는 값을 추가합니다.
    응답을 받은 클라이언트는 브라우저에 쿠키를 저장합니다.
    이후 클라이언트가 같은 도메인에 요청을 보낼 때 헤더에 쿠키를 넣어 보내고 이를 통해 서버가 클라이언트를 식별합니다.
    세션은 서버에 사용자 정보를 저장하고 세션아이디를 부여하는 방식으로 동작합니다.
    클라이언트는 세션아이디를 쿠키에 저장하고 서버와 통신할 때 이 쿠키를 헤더에 서버가 사용자를 식별할 수 있게 합니다.
  <h5> chatgpt </h5> 
    쿠키는 서버에서 클라이언트로 전송되어 클라이언트의 로컬 브라우저에 작은 데이터 조각으로 저장됩니다. 이 데이터는 이름-값 쌍으로 이루어져 있고, 서버가 클라이언트에게 응답할 때 Set-Cookie 헤더를 통해 전달됩니다. 클라이언트는 받은 쿠키를 브라우저에 저장하고, 이후 해당 도메인에 다시 요청을 보낼 때마다 브라우저는 자동으로 해당 쿠키를 서버에 함께 전송하여 상태를 유지하게 됩니다. 이를 통해 로그인 상태, 사용자 선호도, 쇼핑 카트 등의 정보를 저장하고 관리할 수 있습니다.
</details>

<details>
  <summary>결국에 둘다 쿠키를 사용하는데 세션이 더 안전한 이유가 뭔가요?</summary>
  <h5> 초안 </h5> 
    세션을 사용할 경우 세션아이디가 아닌 실제 데이터는 클라이언트에서 수정이 불가능 해 상대적으로 안전합니다.
    하지만 세션아이디가 탈취당한경우에는 세션과 쿠키모두 비슷한 보안적인 위험성을 가지고 있다고 생각합니다. 
    이를 막기위해 httponly, secure, samesite 같은 속성을 사용하는 것이 바람직 합니다.
</details>

<details>
  <summary>JWT는 무엇인가요?</summary>
  <h5> 초안 </h5> 
    json web token의 약자로 인증에 필요한 정보를 json 형식의 토큰에 담아 암호화시켜 사용하는 기술입니다.
    헤더, 페이로드, 서명 3가지 정보로 이루어져 있으며 클라이언트쪽에 저장되고 인가 또는 정보 교환에 주로 사용합니다.
  <h5> chatgpt </h5> 
    JWT (JSON Web Token)은 클레임(정보 조각)을 안전하게 전송하기 위한 일련의 표준을 정의한 토큰 기반의 인증 방식으로, JSON 형식으로 구성된 액세스 토큰을 생성하여 정보를 안전하게 전달하는 데 사용됩니다.
</details>

<details>
  <summary>JWT의 장점은 무엇인가요?</summary>
  <h5> 초안 </h5> 
    서명을 사용해 보안성이 뛰어나고 클라이언트에 저장하기 때문에 세션과 비교해 분산시스템에 더 적합한 기술입니다.
    또한 json을 사용해 범용성이 좋습니다.
    (위변조 방지)
  <h5> chatgpt </h5> 
    JWT의 간편한 구조, 자체 포함된 클레임 정보, 보안적 특성 및 분산 환경 지원으로 인해, 웹 및 애플리케이션에서 효과적이고 확장 가능한 토큰 기반 인증 시스템을 구현할 수 있습니다.
</details>

<details>
  <summary>JWT에서 서명을 사용하는 이유가 뭔가요?</summary>
  <h5> 초안 </h5> 
    무결성을 보장하기 위해 사용합니다. 
    서명을 사용하면 헤도와 페이로드가 변경되지 않았는지를 확인할 수 있습니다. 
  <h5> chatgpt </h5> 
    JWT(JSON Web Token)에서 서명(signature)을 사용하는 주요 이유는 토큰의 무결성을 보장하고 토큰이 발급된 서버에서만 검증이 가능하도록 하는 것입니다. 서명은 토큰이 변조되지 않았음을 확인하기 위한 디지털 서명으로 작용합니다.
</details>

### HTTP

<details>
  <summary>HTTP란 무엇인가요?</summary>
  <h5> 초안 </h5> 
    hypertext transfer protocol의 약자로 애플리케이션 계층에서 사용하며 하이퍼텍스트를 전송하기위해 사용하는 프로 토콜입니다.
  <h5> chatgpt </h5> 
    HTTP(Hypertext Transfer Protocol)는 HTML과 같은 하이퍼미디어 문서를 전송하는 데 사용되는 애플리케이션 프로토콜입니다. 이는 웹에서의 모든 데이터 교환의 기초입니다.
</details>

<details>
  <summary>HTTP의 특징에는 무엇이 있나요?</summary>
  <h5> 초안 </h5> 
    http의 특징으로는 클라이언트 서버 구조, 무상태성이 있습니다.
  <h5> chatgpt </h5> 
    HTTP(Hypertext Transfer Protocol)는 월드와이드웹(World Wide Web)에서 하이퍼텍스트와 다양한 미디어의 전송을 가능하게 하는 상태 비저장 애플리케이션 계층 프로토콜로, 단순성, 헤더를 통한 확장성, 다양한 통신 지원이 특징입니다.
</details>

<details>
  <summary>HTTP/1.0과 HTTP/1.1의 주요 차이점은 무엇입니까?</summary>
  <h5> 초안 </h5> 
    1.1 버전은 연결을 일정한 시간동안 유지해 기존의 요청할 때마다 연결 다시 해야한다는 문제점을 해결했습니다.
    또한 응답을 기다리지 않고 순차적으로 요청을 보내고 처리하는 방식으로 속도를 높혔습니다.
  <h5> chatgpt </h5> 
    HTTP/1.1은 동일한 IP 주소에서 여러 웹사이트를 처리하기 위한 지속적인 연결, 파이프라인 및 호스트 헤더 지원을 포함하여 HTTP/1.0에 비해 몇 가지 개선 사항을 도입했습니다.
</details>

<details>
  <summary>HTTP/2.0의 특징은 무엇인가요?</summary>
  <h5> 초안 </h5> 
    2.0 버전에는 헤더압축, 서버 푸시, 멀티플렉싱 등의 기능이 추가됐습니다.
    서버푸시는 요청에 대해 여러 응답을 보내는 기술이며, 
    멀티플렉싱은 하나의 연결에 여러 스트림을 생성해 동시에 여러 요청을 처리할 수 있는 기술입니다.
  <h5> chatgpt </h5> 
    HTTP/2는 멀티플렉싱, 헤더 압축, 요청 우선순위 지정과 같은 기능을 통해 성능을 향상시켜 단일 연결을 통해 여러 요청과 응답을 동시에 처리할 수 있도록 합니다.
</details>

<details>
  <summary>HTTP/3.0이 TCP가 아닌 UDP를 기반으로 한 이유</summary>
  <h5> 초안 </h5> 
    tcp가 가진 문제를 해결하기위해 udp를 사용했습니다.
    멀티플렉싱을 적용해도 여전히 TCP는 head of line blocking 문제가 있습니다. 
    quic는 독립 스트림을 사용해 한 스트림에 holb 문제가 발생해도 다른 스트림에 영향을 주지않도록 해 문제를 개선했습니다. 
  <h5> chatgpt </h5> 
    HTTP/3.0은 대기 시간을 줄이고, HOL 차단을 해결하고, 연결 마이그레이션을 활성화하고, 혼잡 제어를 개선하고, 보안을 강화하고, QUIC pro를 통해 효율적인 멀티플렉싱 및 스트림 우선 순위 지정을 제공하기 위해 TCP 대신 UDP를 기반으로 했습니다.
</details>

<details>
  <summary>HTTP와 HTTPS의 차이점은 무엇인가요?</summary>
  <h5> 초안 </h5> 
    http와 https는 다른 프로토콜이 아닌 http에 암호화 프로토콜을 추가해 데이터를 안전하게 전송 할 수 있는 버전이 https입니다.
  <h5> chatgpt </h5> 
    HTTPS(Hypertext Transfer Protocol Secure)는 암호화(일반적으로 TLS 또는 SSL)를 사용하여 클라이언트와 서버 간의 통신을 보호하고 데이터 기밀성과 무결성을 보장하는 보안 버전의 HTTP입니다.
</details>

<details>
  <summary>HTTPS의 통신과정에 대해 설명해 주세요</summary>
  <h5> 초안 </h5> 
    https로 통신하기위해서는 ssl handshake라는 과정이 필요합니다.
    먼저 클라이언트가 서버에 랜덤데이터를 보내고 이를 받은 서버는 서버에서 생성한 랜덤데이터와 인증서를 클라이언트에 보냅니다.
    클라이언트는 인증서를 공개키로 복호화해 사이트의 공개키를 얻을 수 있습니다.
    클라이언트의 랜덤데이터와 서버의 랜덤데이터를 조합해 대칭키로 사용하는데 이를 사이트의 공개키로 암호화해 서버에 전송합니다.
    서버는 비밀키를 통해 복호화를 진행해 대칭키를 얻을 수 있습니다.
    이후에는 서로가 가진 대칭키를 통해 데이터를 안전하게 전송할 수 있습니다.
  <h5> chatgpt </h5> 
    HTTPS 작업에는 보안 연결 시작, SSL/TLS 인증서를 사용한 서버 인증, SSL/TLS 핸드셰이크를 통한 암호화 매개변수 협상, 데이터 암호화 및 보안 전송, 마지막으로 세션이 종료될 때 보안 연결 종료가 포함됩니다.
</details>

### CORS

<details>
  <summary>CORS는 무엇인가요?</summary>
  <h5> 초안 </h5> 
    cors는 cross origin resource sharing으로 다른 오리진 간 리소스 접근을 가능하게하는 기술입니다.
    다른 오리진이 이를 설정하지 않은 서버에 요청을 보내면 cors 에러가 발생하게 됩니다.
  <h5> chatgpt </h5> 
    CORS는 한 도메인의 웹페이지가 다른 도메인의 리소스를 요청하고 상호 작용하는 방식을 제어하기 위해 웹 브라우저에서 구현하는 보안 기능으로, 원본 간 보안 취약성을 방지하는 데 도움이 됩니다.
</details>

### DNS

<details>
  <summary>DNS는 무엇인가요?</summary>
  <h5> 초안 </h5> 
    dns는 domain name system으로 naver.com같은 도메인을 192.168.10.1 ip주소로 변환하는 시스템입니다.
    dns로 인해 외우기 어려운 ip주소 대신 도메인 이름을 사용해 사이트에 접속 할 수 있습니다.
  <h5> chatgpt </h5> 
    DNS는 도메인 이름 시스템(Domain Name System)을 의미합니다.
</details>

<details>
  <summary>로드밸런싱이 DNS에서 어떻게 사용될 수 있을까요?</summary>
  <h5> 초안 </h5> 
    dns를 사용해 다수의 ip를 단일 도메인으로 묶어 트래픽을 분산시킬 수 있습니다.
  <h5> chatgpt </h5> 
    DNS 기반 부하 분산에는 여러 IP 주소를 단일 도메인 이름과 연결하여 DNS가 해당 주소 간에 들어오는 트래픽을 분산시킬 수 있도록 하는 작업이 포함됩니다.
</details>

<details>
  <summary>브라우저에 google.com을 검색하면 일어나는 과정을 설명해 주세요</summary>
  <h5> 초안 </h5> 
    dns를 사용해 다수의 ip를 단일 도메인으로 묶어 트래픽을 분산시킬 수 있습니다.
  <h5> chatgpt </h5> 
    DNS 기반 부하 분산에는 여러 IP 주소를 단일 도메인 이름과 연결하여 DNS가 해당 주소 간에 들어오는 트래픽을 분산시킬 수 있도록 하는 작업이 포함됩니다.
</details>

<details>
  <summary>DNS의 반복적질의와 재귀적 질의의 차이점에 대해 설명해주세요</summary>
  <h5> 초안 </h5> 
    반복적방식은 최종 ip 주소를 받을 때 까지 클라이언트가 반복적으로 질의를 하는 방식으로, 
    각각의 dns서버는 다음에 질의를 보낼 dns서버의 정보를 클라이언트에 반환합니다.
    재귀적방식은 클라이언트가 질의를 보낸  dns서버가 직접 하위 dns서버에 질의를 보내 ip주소를 습득한 후 클라이언트에 반환하는 방식입니다.
  <h5> chatgpt </h5> 
    반복적 질의는 DNS 서버가 질의를 받아 다른 DNS 서버에게 계속해서 전달하여 최종 답을 찾는 방식이며, 재귀적 질의는 DNS 서버가 질의를 받아 필요한 경우 하위 DNS 서버들에게 질의를 보내 최종 응답을 클라이언트에게 제공하는 방식입니다.
</details>

### DHCP 

<details>
  <summary>DHCP는 무엇을 의미하며, 네트워킹에서 DHCP의 주요 역할은 무엇입니까?</summary>
  <h5> 초안 </h5> 
    DHCP는 ip주소, 서브넷마스크 등을 자동으로 할당해주는 프로토콜입니다.
    ip를 자동으로 할당하기 때문에 ip충돌을 막을 수 있고 효율적입니다.
  <h5> chatgpt </h5> 
    DHCP는 Dynamic Host Configuration Protocol(동적 호스트 구성 프로토콜)을 의미하며, DHCP의 주요 역할은 IP 주소와 구성 정보를 네트워크의 장치에 자동으로 할당하는 것입니다.
</details>

<details>
  <summary>DHCP 임대 프로세스는 어떻게 진행되나요?</summary>
  <h5> 초안 </h5> 
    먼저 클라이언트가 dhcp서버를 찾기위해 메시지를 브로드캐스트로 전송합니다.
    메시지를 수신한 서버는 할당할 ip주소, 서브넷, DNS등의 정보를 클라이언트에 전송합니다.
    클라이언트는 받은 ip주소와 dhcp서버 정보를 브로드캐스트로 전송합니다.
    ip주소를 사용하겠다는 요청을 받으면 dhcp서버는 해당 ip를 어떤 클라이언트가 언제부터 사용했는지 정보를 기록하고 request 메시지를 정상적으로 수신했다고 응답합니다.
  <h5> chatgpt </h5> 
    DHCP 임대 프로세스에는 클라이언트가 DHCP 서버에서 IP 주소를 요청하는 과정이 포함됩니다. 서버는 IP 주소를 제공하고 클라이언트는 해당 제안을 수락하거나 거부할 수 있습니다. 수락한 경우 클라이언트는 지정된 기간 동안 임대를 허가받으며 그 이후에는 임대를 갱신해야 합니다.
</details>

<details>
  <summary>DHCP Request단계에서 브로드캐스트를 사용하는 이유는 뭔가요?</summary>
  <h5> 초안 </h5> 
    request 메시지를 브로드캐스트로 보내는 이유는 dhcp서버가 1대 이상일 수 있기 때문입니다.
  <h5> chatgpt </h5> 
</details>

### URI, URL, URN

<details>
  <summary>URI란 무엇입니까?</summary>
  <h5> 초안 </h5> 
    통합 자원 식별자의 줄임말로 인터넷의 자원을 식별할 수 있는 문자열입니다.
    URL와 URN이 URI에 속하고있습니다.
  <h5> chatgpt </h5> 
    URI(Uniform Resource Identifier)는 특정 리소스를 고유하게 식별하는 문자열입니다. 이는 URL과 URN을 모두 포함합니다.
</details>
